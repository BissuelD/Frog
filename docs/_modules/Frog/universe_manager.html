<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Frog.universe_manager &#8212; Frog 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <link rel="stylesheet" type="text/css" href="../../_static/_static/css/s4defs-roles.css" />
    <script src="../../_static/documentation_options.js?v=8d563738"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for Frog.universe_manager</h1><div class="highlight"><pre>
<span></span><span class="c1">##############################################################################</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#    FROG: FROm molecular dynamics to second harmonic Generation             #</span>
<span class="c1">#    Copyright (C) 2024                                                      #</span>
<span class="c1">#    Author list                                                             #</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#    Guillaume Le Breton                                                     #</span>
<span class="c1">#    Oriane Bonhomme                                                         #</span>
<span class="c1">#    Emmanuel Benichou                                                       #</span>
<span class="c1">#    Claire Loison                                                           #</span>
<span class="c1">#                                                                            # </span>
<span class="c1">#    This program is free software: you can redistribute it and/or modify    #</span>
<span class="c1">#    it under the terms of the GNU General Public License as published by    #</span>
<span class="c1">#    the Free Software Foundation, either version 3 of the License, or       #</span>
<span class="c1">#    (at your option) any later version.                                     #</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#    This program is distributed in the hope that it will be useful,         #</span>
<span class="c1">#    but WITHOUT ANY WARRANTY; without even the implied warranty of          #</span>
<span class="c1">#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           #</span>
<span class="c1">#    GNU General Public License for more details.                            #</span>
<span class="c1">#                                                                            #</span>
<span class="c1">#    You should have received a copy of the GNU General Public License       # </span>
<span class="c1">#    along with this program.  If not, see &lt;https://www.gnu.org/licenses/    #</span>
<span class="c1">#                                                                            #</span>
<span class="c1">##############################################################################</span>

<span class="kn">import</span> <span class="nn">importlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span> 
<span class="kn">import</span> <span class="nn">MDAnalysis</span>    
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">Frog.toolbox</span> <span class="k">as</span> <span class="nn">toolbox</span>
<span class="kn">import</span> <span class="nn">Frog.geometry_manager</span> <span class="k">as</span> <span class="nn">geometry_manager</span>
<span class="kn">import</span> <span class="nn">Frog.dalton_manager_module</span> <span class="k">as</span> <span class="nn">dalton_manager_module</span>
<span class="kn">import</span> <span class="nn">Frog.messages</span> <span class="k">as</span> <span class="nn">messages</span>
<span class="kn">import</span> <span class="nn">Frog.error_messages</span> <span class="k">as</span> <span class="nn">error_messages</span>

<span class="c1"># import Frog.electric_field_module as electric_field_module  # probleme with this import because electric_field_module also use this module, rather the used function is imported separetly: </span>
<span class="kn">import</span> <span class="nn">Frog.electric_field_module</span>
<span class="c1">#from Frog.electric_field_module import compute_electric_field_from_electro_description as electric_field_module_compute_electric_field_from_electro_description</span>
<span class="c1">#from Frog.electric_field_module import add_single_contribution_electric_field_pbc as electric_field_module_add_single_contribution_electric_field_pbc</span>

<span class="kn">from</span> <span class="nn">Frog.class_modules</span> <span class="kn">import</span> <span class="n">SingleMoleculeParameter</span>

<span class="kn">import</span> <span class="nn">Frog.class_OpticalParameter</span> <span class="c1">#import QMDescription</span>
<span class="c1">#import Frog.class_OpticalParameter #import ElectrostaticDescription</span>

<div class="viewcode-block" id="closest_idx">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.closest_idx">[docs]</a>
<span class="k">def</span> <span class="nf">closest_idx</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lst</span> <span class="o">-</span> <span class="n">K</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">())</span>
    <span class="k">return</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span></div>


<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="trajectory_load_old">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.trajectory_load_old">[docs]</a>
<span class="k">def</span> <span class="nf">trajectory_load_old</span><span class="p">(</span><span class="n">GP</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">try_cut_traj</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    TODO</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">try_cut_traj</span> <span class="ow">and</span> <span class="n">GP</span><span class="o">.</span><span class="n">MD_cut_trajectory</span><span class="p">:</span>
        <span class="n">name_file_traj</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">dir_mol_times</span><span class="p">,</span> <span class="s1">&#39;cut_trajectory_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.dcd&#39;</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_file_name_topology</span><span class="p">,</span> <span class="n">name_file_traj</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;LAMMPS&#39;</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_file_name_topology</span><span class="p">,</span> <span class="n">GP</span><span class="o">.</span><span class="n">MD_file_name_traj</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_file_type</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">time_step</span><span class="o">*</span><span class="n">GP</span><span class="o">.</span><span class="n">trotter_step</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_convertion_to_angstrom</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span> <span class="c1">#change unit of the MD trajectory</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_convertion_to_angstrom</span><span class="p">)</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="o">*</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_convertion_to_angstrom</span><span class="p">)</span> 
        
    <span class="n">L_box_size</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">)</span></div>


<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="trajectory_load">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.trajectory_load">[docs]</a>
<span class="k">def</span> <span class="nf">trajectory_load</span><span class="p">(</span><span class="n">GP</span><span class="p">,</span> <span class="n">time_step</span><span class="p">,</span> <span class="n">try_cut_traj</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    TODO</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">try_cut_traj</span> <span class="ow">and</span> <span class="n">GP</span><span class="o">.</span><span class="n">MD_cut_trajectory</span><span class="p">:</span>
        <span class="n">name_file_traj</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">dir_mol_times</span><span class="p">,</span> <span class="s1">&#39;cut_trajectory_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time_step</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.dcd&#39;</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_file_name_topology</span><span class="p">,</span> <span class="n">name_file_traj</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;LAMMPS&#39;</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>   
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_file_name_topology</span><span class="p">,</span> <span class="n">GP</span><span class="o">.</span><span class="n">MD_file_name_traj</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_file_type</span><span class="p">)</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">trajectory</span><span class="p">[</span><span class="n">time_step</span><span class="o">*</span><span class="n">GP</span><span class="o">.</span><span class="n">trotter_step</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_convertion_to_angstrom</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span> <span class="c1">#change unit of the MD trajectory</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_convertion_to_angstrom</span><span class="p">)</span>
        <span class="n">ts</span><span class="o">.</span><span class="n">positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">positions</span><span class="o">*</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_convertion_to_angstrom</span><span class="p">)</span> 
        
    <span class="n">pbc</span> <span class="o">=</span> <span class="n">geometry_manager</span><span class="o">.</span><span class="n">PBC</span><span class="p">(</span><span class="n">GP</span><span class="p">,</span><span class="n">ts</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">pbc</span><span class="p">)</span></div>


<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="trajectory_selection_for_residues">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.trajectory_selection_for_residues">[docs]</a>
<span class="k">def</span> <span class="nf">trajectory_selection_for_residues</span><span class="p">(</span><span class="n">GP</span><span class="p">,</span> <span class="n">L_key_mol</span><span class="p">):</span>   
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the number of the first and last atom of the residue selection. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_file_name_topology</span><span class="p">,</span> <span class="n">GP</span><span class="o">.</span><span class="n">MD_file_name_traj</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">GP</span><span class="o">.</span><span class="n">MD_file_type</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;resid 1-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">L_key_mol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">GP</span><span class="o">.</span><span class="n">total_number_molecule</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s1">&#39;resid 1-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">L_key_mol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        
    <span class="k">return</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">])</span></div>


<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="QM_preparation_PE_and_PE_plus_QMBox">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.QM_preparation_PE_and_PE_plus_QMBox">[docs]</a>
<span class="k">def</span> <span class="nf">QM_preparation_PE_and_PE_plus_QMBox</span><span class="p">(</span><span class="n">GP</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">pbc</span><span class="p">,</span> <span class="n">molecule_type_module</span><span class="p">,</span> <span class="n">moleculetype</span><span class="p">,</span> <span class="n">sdparameter</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">,</span> <span class="n">kkk</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">L_moleculetype</span><span class="p">,</span> <span class="n">L_target_mean_pos</span><span class="p">,</span> <span class="n">pos_mol_target</span><span class="p">,</span> <span class="n">QM_file_localization_name</span><span class="p">):</span>
        
    <span class="n">L_box_size</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">L_box_size</span>
    <span class="c1"># Initialize the qmdescription of the target molecule:</span>
    <span class="n">qmdescription</span> <span class="o">=</span> <span class="n">molecule_type_module</span><span class="o">.</span><span class="n">qm_target_description</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">QMDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">pos_mol_target</span><span class="o">-</span><span class="n">L_target_mean_pos</span><span class="p">)</span>
    <span class="n">qmparameter_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="p">)</span>
    <span class="n">L_coordinate_neigh_qmbox</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="c1"># Static Electrostatic:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qmparameter_temp</span><span class="o">.</span><span class="n">static_electric_field</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">qmparameter_temp</span><span class="o">.</span><span class="n">static_electric_field_direction</span> <span class="o">==</span> <span class="s1">&#39;Molecular&#39;</span><span class="p">:</span> <span class="c1"># the value of the electrostatic field should be rotated in the molecular frame</span>
            <span class="c1">#print(&#39;kkk:&#39;, kkk)</span>
            <span class="c1">#print(&#39;called in L_molecule:&#39;, kkk-moleculetype.L_key_mol[0])</span>
            <span class="c1">#print(&#39;rot matrix used:&#39;, getattr(moleculetype.L_molecule[kkk-moleculetype.L_key_mol[0]], &#39;rot_mat&#39;))</span>
            <span class="n">qmparameter_temp</span><span class="o">.</span><span class="n">static_electric_field</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">rotate_1st_order_tensor</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_molecule</span><span class="p">[</span><span class="n">kkk</span><span class="o">-</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;rot_mat&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">qmparameter_temp</span><span class="o">.</span><span class="n">static_electric_field</span><span class="p">)</span> <span class="c1"># from molecular to lab</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c1"># external_electric_field = qmparameter_temp.static_electric_field</span>
            
    <span class="c1"># Initialize the electrostatic description:</span>
    <span class="n">electro_description</span> <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Initialize the electric field felt by the molecule generated by the PE environment</span>
        <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">long_range_switch</span><span class="p">:</span>
            <span class="n">long_range_distance_switch</span> <span class="o">=</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">long_range_distance_switch</span>
            <span class="n">L_E_long_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">L_dE_long_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Update the QM box and/or the electrostatic description using the neighborhood: </span>
        <span class="n">max_distance_neigh</span> <span class="o">=</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">max_pe_distance_neigh</span>
        <span class="c1"># L_environment, L_neighbourhood_cleaned = universe_manager.environement_manager(kkk, L_target_mean_pos, molecule_type_module, max_distance_neigh, GP, u, ts, L_box_size)</span>
        <span class="n">L_list_name_MT</span><span class="p">,</span> <span class="n">L_neighbourhood_names_number</span><span class="p">,</span> <span class="n">L_environment</span> <span class="o">=</span> <span class="n">environement_builder_return_position</span><span class="p">(</span><span class="n">kkk</span><span class="p">,</span> <span class="n">L_target_mean_pos</span><span class="p">,</span> <span class="n">molecule_type_module</span><span class="p">,</span> <span class="n">max_distance_neigh</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">pbc</span><span class="p">)</span> 

        <span class="c1"># Update the enviromnent list if special selections are asked:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">more_select_environment</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">more_select_environment</span> <span class="o">==</span> <span class="s1">&#39;Absolute position&#39;</span><span class="p">:</span>
                <span class="n">L_list_name_MT</span><span class="p">,</span> <span class="n">L_neighbourhood_names_number</span><span class="p">,</span> <span class="n">L_environment</span> <span class="o">=</span> <span class="n">geometry_manager</span><span class="o">.</span><span class="n">selection_absolute_position</span><span class="p">(</span><span class="n">L_list_name_MT</span><span class="p">,</span> <span class="n">L_neighbourhood_names_number</span><span class="p">,</span> <span class="n">L_environment</span><span class="p">,</span> <span class="n">L_target_mean_pos</span><span class="p">,</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">L_moleculetype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">more_select_environment</span> <span class="o">==</span> <span class="s1">&#39;Relative position&#39;</span><span class="p">:</span>
                <span class="n">L_list_name_MT</span><span class="p">,</span> <span class="n">L_neighbourhood_names_number</span><span class="p">,</span> <span class="n">L_environment</span> <span class="o">=</span> <span class="n">geometry_manager</span><span class="o">.</span><span class="n">selection_relative_position</span><span class="p">(</span><span class="n">L_list_name_MT</span><span class="p">,</span> <span class="n">L_neighbourhood_names_number</span><span class="p">,</span> <span class="n">L_environment</span><span class="p">,</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">L_moleculetype</span><span class="p">)</span>

                <span class="c1">#print(len(L_list_name_MT), len(L_neighbourhood_names_number), len(L_environment))</span>
                <span class="c1">#print(L_list_name_MT)</span>
                <span class="c1">#print(L_neighbourhood_names_number)</span>
                <span class="c1">#print(L_environment)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_environment</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span> <span class="c1">#case where there are neighbourgs:</span>
            <span class="n">trotter_neigh</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">K_MT_trotter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_list_name_MT</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">name_neigh_temp</span> <span class="o">=</span> <span class="n">L_list_name_MT</span><span class="p">[</span><span class="n">K_MT_trotter</span><span class="p">]</span>
                <span class="n">neigh_molecule_type_module</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">toolbox</span><span class="o">.</span><span class="n">creat_name_for_MT_module_load</span><span class="p">(</span><span class="n">name_neigh_temp</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">k_mol_rep</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">L_mt_key_mt</span><span class="p">)):</span> <span class="c1"># load the MT  </span>
                    <span class="k">if</span> <span class="n">GP</span><span class="o">.</span><span class="n">L_mt_key_mt</span><span class="p">[</span><span class="n">k_mol_rep</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">name_neigh_temp</span><span class="p">:</span>
                        <span class="n">molecule_type_neigh</span> <span class="o">=</span> <span class="n">L_moleculetype</span><span class="p">[</span><span class="n">k_mol_rep</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">k_neigh_trotter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_neighbourhood_names_number</span><span class="p">[</span><span class="n">K_MT_trotter</span><span class="p">]),</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># Goes over all the neighbourging molecules. </span>
                    <span class="n">num_neigh_temp</span> <span class="o">=</span> <span class="n">L_neighbourhood_names_number</span><span class="p">[</span><span class="n">K_MT_trotter</span><span class="p">][</span><span class="n">k_neigh_trotter</span><span class="p">]</span> <span class="c1"># number of the molecule wrt the global labelling.</span>
                    <span class="n">pos_neigh_temp</span> <span class="o">=</span> <span class="n">L_environment</span><span class="p">[</span><span class="n">trotter_neigh</span><span class="p">]</span> <span class="c1"># Position of the neighbourg molecule in the target molecule framework </span>

                    <span class="n">add_to_electro_description</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># check if the neighbors should be added to the PE environement or in QM box / long range part:</span>
                    <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">calculation_style</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PE + QM box&#39;</span><span class="p">]:</span> <span class="c1"># Some molecule have to be part of the QM box instead of the electrostatic environment.</span>
                        <span class="n">d_neigh_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">neigh_molecule_type_module</span><span class="o">.</span><span class="n">compute_mean_position</span><span class="p">(</span><span class="n">pos_neigh_temp</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># distance between the mean position of this neighbourg and the target molecule</span>
                        <span class="k">if</span> <span class="n">d_neigh_target</span> <span class="o">&lt;</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">max_qm_box_distance_neigh</span><span class="p">:</span> <span class="c1"># this neighbourg should be add to the QM box.</span>
                            <span class="n">add_to_electro_description</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">qmdescription_toadd</span> <span class="o">=</span> <span class="n">neigh_molecule_type_module</span><span class="o">.</span><span class="n">qm_target_description</span><span class="p">(</span><span class="n">molecule_type_neigh</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">QMDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">pos_neigh_temp</span><span class="p">)</span>
                            <span class="n">qmdescription</span><span class="o">.</span><span class="n">merge_mol</span><span class="p">(</span><span class="n">qmdescription_toadd</span><span class="p">)</span> <span class="c1"># Add the atoms of the neighbourgs in the QM box</span>

                            <span class="k">try</span><span class="p">:</span> <span class="c1"># select the most precise QM parameter </span>
                                <span class="n">qmparameter_neigh</span> <span class="o">=</span> <span class="n">molecule_type_neigh</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span>
                            <span class="k">except</span><span class="p">:</span> <span class="c1"># qmparameter not implemented for this molecule type for the QM box. </span>
                                <span class="n">qmparameter_neigh</span> <span class="o">=</span> <span class="n">molecule_type</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span>
                            <span class="n">qmparameter_temp</span><span class="o">.</span><span class="n">merge_qmparameter</span><span class="p">(</span><span class="n">qmparameter_neigh</span><span class="p">,</span> <span class="n">GP</span><span class="p">)</span> 

                            <span class="c1"># Write the .pot file and the .xyz file if asked</span>
                            <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">write_xyz_environment</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">coordinate</span> <span class="ow">in</span> <span class="n">qmdescription_toadd</span><span class="o">.</span><span class="n">L_coordinate</span><span class="p">:</span>
                                    <span class="n">L_coordinate_neigh_qmbox</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span>   
                    <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">long_range_switch</span><span class="p">:</span>
                        <span class="n">d_neigh_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">neigh_molecule_type_module</span><span class="o">.</span><span class="n">compute_mean_position</span><span class="p">(</span><span class="n">pos_neigh_temp</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># distance between the mean position of this neighbourg and the target molecule</span>
                        <span class="k">if</span>  <span class="n">d_neigh_target</span> <span class="o">&gt;</span> <span class="n">long_range_distance_switch</span><span class="p">:</span> <span class="c1"># this neighbourg should be add to the long part.</span>
                            <span class="n">electro_description_for_long</span> <span class="o">=</span> <span class="n">neigh_molecule_type_module</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">pos_neigh_temp</span><span class="p">)</span> <span class="c1"># PE level should be 0 since it is added as long part: no polarizability!</span>
                            <span class="n">E_long_range_temp</span><span class="p">,</span> <span class="n">dE_long_range_temp</span> <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">add_single_contribution_electric_field_pbc</span><span class="p">(</span><span class="n">electro_description_for_long</span><span class="p">)</span> <span class="c1"># in atomic units</span>
                            <span class="n">L_E_long_range</span> <span class="o">+=</span> <span class="n">E_long_range_temp</span>
                            <span class="n">L_dE_long_range</span> <span class="o">+=</span> <span class="n">dE_long_range_temp</span>
                            <span class="n">add_to_electro_description</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># used in the long range part: should not be added to the short one.</span>

                    <span class="k">if</span> <span class="n">add_to_electro_description</span><span class="p">:</span> <span class="c1"># should be added to the PE direct environment</span>
                        <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># their is polarizability to add or not depending on the neighborg position wrt to the target molecule: </span>
                            <span class="n">d_neigh_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">neigh_molecule_type_module</span><span class="o">.</span><span class="n">compute_mean_position</span><span class="p">(</span><span class="n">pos_neigh_temp</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># distance between the mean position of this neighbourg and the target molecule</span>
                            <span class="k">if</span> <span class="n">d_neigh_target</span> <span class="o">&lt;</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">max_pe_polarization_distance_neigh</span><span class="p">:</span> <span class="c1"># this neighbourg should be add with PE order 1: polarization taken into account. </span>
                                <span class="n">electro_description_toadd</span> <span class="o">=</span> <span class="n">neigh_molecule_type_module</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">pos_neigh_temp</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">electro_description_toadd</span> <span class="o">=</span> <span class="n">neigh_molecule_type_module</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">pos_neigh_temp</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span> 
                            <span class="n">electro_description_toadd</span> <span class="o">=</span> <span class="n">neigh_molecule_type_module</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">pos_neigh_temp</span><span class="p">)</span>

                        <span class="n">electro_description</span><span class="o">.</span><span class="n">merge_mol</span><span class="p">(</span><span class="n">electro_description_toadd</span><span class="p">)</span>
                    <span class="n">trotter_neigh</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># DALTON input file: </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Old version of the code where the dalton file where only generated once. Now the .dal may have modification for every molecule: therefore the .dal file is written each time. This avoid to forget to write in futur cases. It is more time-consuming but it appears to Frog dev that it should be more maintenable!!! see below for the olf version. </span>
<span class="sd">   </span>
<span class="sd">    # since the .dal test file have been generated during the initialization, we can use this one for this molecule type:</span>
<span class="sd">    file_to_copy = toolbox.concatenate_path(GP.dir_torun_QM , &#39;exemple_dalton_input_&#39; + moleculetype.name + &#39;.dal&#39;)</span>
<span class="sd">    file_to_creat_dal = toolbox.concatenate_path(QM_file_localization_name , &#39;dalton.dal&#39;)</span>
<span class="sd">    shutil.copy(file_to_copy, file_to_creat_dal)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">file_dal</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">QM_file_localization_name</span> <span class="p">,</span> <span class="s1">&#39;dalton.dal&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">long_range_switch</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">dalton_manager_module</span><span class="o">.</span><span class="n">generate_inp_dal</span><span class="p">(</span><span class="n">qmparameter_temp</span><span class="p">,</span> <span class="n">file_dal</span><span class="p">,</span> <span class="n">molecular_electric_field</span><span class="o">=</span><span class="n">L_E_long_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dalton_manager_module</span><span class="o">.</span><span class="n">generate_inp_dal</span><span class="p">(</span><span class="n">qmparameter_temp</span><span class="p">,</span> <span class="n">file_dal</span><span class="p">,</span> <span class="n">molecular_electric_field</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dalton_manager_module</span><span class="o">.</span><span class="n">generate_inp_dal</span><span class="p">(</span><span class="n">qmparameter_temp</span><span class="p">,</span> <span class="n">file_dal</span><span class="p">,</span> <span class="n">molecular_electric_field</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
    <span class="c1"># MOLECULE input file:</span>
    <span class="n">file_mol</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">QM_file_localization_name</span> <span class="p">,</span> <span class="s1">&#39;molecule.mol&#39;</span><span class="p">)</span>
    <span class="n">dalton_manager_module</span><span class="o">.</span><span class="n">generate_inp_mol</span><span class="p">(</span><span class="n">qmparameter_temp</span><span class="p">,</span> <span class="n">file_mol</span><span class="p">,</span> <span class="n">qmdescription</span><span class="p">,</span> <span class="n">message_1</span><span class="o">=</span><span class="s1">&#39;Laboratory frame&#39;</span><span class="p">)</span> 

    <span class="c1"># Write the .pot file and the .xyz file if asked</span>
    <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">calculation_style</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PE&#39;</span><span class="p">,</span> <span class="s1">&#39;PE + QM box&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">write_xyz_environment</span><span class="p">:</span>
            <span class="n">nbr_atom_total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_mol_target</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_coordinate_neigh_qmbox</span><span class="p">)</span><span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">electro_description</span><span class="o">.</span><span class="n">L_localization_type</span><span class="p">)</span>
            <span class="n">toolbox</span><span class="o">.</span><span class="n">write_xyz_mol</span><span class="p">(</span><span class="n">nbr_atom_total</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span> <span class="k">for</span> <span class="n">K</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_mol_target</span><span class="p">),</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">pos_mol_target</span><span class="o">-</span><span class="n">L_target_mean_pos</span><span class="p">,</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">QM_file_localization_name</span><span class="p">,</span> <span class="s1">&#39;potential.xyz&#39;</span><span class="p">),</span> <span class="n">type_writting</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_coordinate_neigh_qmbox</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">toolbox</span><span class="o">.</span><span class="n">write_xyz_mol</span><span class="p">(</span><span class="n">nbr_atom_total</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Y&#39;</span> <span class="k">for</span> <span class="n">K</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_coordinate_neigh_qmbox</span><span class="p">),</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">L_coordinate_neigh_qmbox</span><span class="p">,</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">QM_file_localization_name</span><span class="p">,</span> <span class="s1">&#39;potential.xyz&#39;</span><span class="p">),</span> <span class="n">type_writting</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
            
   <span class="c1"># POTENTIAL input file: first find the neighbourghood:</span>
    <span class="n">file_pe</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">QM_file_localization_name</span><span class="p">,</span> <span class="s1">&#39;potential.pot&#39;</span><span class="p">)</span>
    <span class="n">dalton_manager_module</span><span class="o">.</span><span class="n">generate_inp_pot</span><span class="p">(</span><span class="n">electro_description</span><span class="p">,</span> <span class="n">file_pe</span><span class="p">,</span> <span class="n">xyz_environemnt</span><span class="o">=</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">write_xyz_environment</span><span class="p">)</span>         
        
    <span class="c1"># Compute the electric field felt by the molecul generated by the PE environment:</span>
    <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">compute_electric_field_PE</span><span class="p">:</span> 
        <span class="n">electric_field_direct_lab</span><span class="p">,</span> <span class="n">d_electric_field_direct_lab</span>  <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">compute_electric_field_from_electro_description</span><span class="p">(</span><span class="n">electro_description</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># the target molecule is already centered at [0, 0, 0]. The result is in V/A. </span>
        <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">long_range_switch</span><span class="p">:</span>
            <span class="c1">#print(&#39;long range a.u.:&#39;, L_E_long_range)</span>
            <span class="n">L_E_long_range</span> <span class="o">=</span> <span class="n">L_E_long_range</span><span class="o">*</span><span class="mf">51.42206747</span> <span class="c1"># convert from atomic unit to  V/A</span>
            <span class="n">L_dE_long_range</span> <span class="o">=</span> <span class="n">L_dE_long_range</span><span class="o">*</span><span class="mf">97.17362428</span> <span class="c1"># in V/A^2 </span>
            <span class="c1">#print(&#39;short range V/A:&#39;, electric_field_direct_lab)</span>
            <span class="c1">#print(&#39;long range V/A:&#39;, L_E_long_range)</span>
            <span class="c1">#print(&#39;total V/A:&#39;, electric_field_direct_lab+L_E_long_range)</span>
            <span class="n">L_value_electric_field</span> <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">to_store_electric_field</span><span class="p">(</span><span class="n">electric_field_direct_lab</span><span class="p">,</span> <span class="n">d_electric_field_direct_lab</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_molecule</span><span class="p">[</span><span class="n">kkk</span><span class="o">-</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;rot_mat&#39;</span><span class="p">),</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;direct+long&#39;</span><span class="p">,</span> <span class="n">E_long</span><span class="o">=</span><span class="n">L_E_long_range</span><span class="p">,</span> <span class="n">dE_long</span><span class="o">=</span><span class="n">L_dE_long_range</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#print(&#39;short range V/A:&#39;,electric_field_direct_lab)</span>
            <span class="n">L_value_electric_field</span> <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">to_store_electric_field</span><span class="p">(</span><span class="n">electric_field_direct_lab</span><span class="p">,</span> <span class="n">d_electric_field_direct_lab</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_molecule</span><span class="p">[</span><span class="n">kkk</span><span class="o">-</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;rot_mat&#39;</span><span class="p">),</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;direct&#39;</span><span class="p">)</span>
        <span class="n">name_attr_electric_field</span> <span class="o">=</span> <span class="s1">&#39;electric_field_PE&#39;</span>
        <span class="c1"># print(kkk, name_attr_electric_field, L_E_PE)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_molecule</span><span class="p">[</span><span class="n">kkk</span><span class="o">-</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">name_attr_electric_field</span><span class="p">,</span> <span class="n">L_value_electric_field</span><span class="p">)</span> </div>


<span class="c1">#################################################################################################################################</span>
        
<div class="viewcode-block" id="QM_preparation_PE_long">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.QM_preparation_PE_long">[docs]</a>
<span class="k">def</span> <span class="nf">QM_preparation_PE_long</span><span class="p">(</span><span class="n">GP</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">,</span> <span class="n">molecule_type_module</span><span class="p">,</span> <span class="n">moleculetype</span><span class="p">,</span> <span class="n">sdparameter</span><span class="p">,</span> <span class="n">name_attr</span><span class="p">,</span> <span class="n">kkk</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">L_moleculetype</span><span class="p">,</span> <span class="n">L_target_mean_pos</span><span class="p">,</span> <span class="n">pos_mol_target</span><span class="p">,</span> <span class="n">QM_file_localization_name</span><span class="p">):</span>
    <span class="c1"># DALTON input file: since the .dal test file have been generated during the initialization, we can use this one for this molecule type:</span>

    <span class="c1"># Initialize the qmdescription of the target molecule:</span>
    <span class="n">qmdescription</span> <span class="o">=</span> <span class="n">molecule_type_module</span><span class="o">.</span><span class="n">qm_target_description</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">QMDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">pos_mol_target</span><span class="o">-</span><span class="n">L_target_mean_pos</span><span class="p">)</span>
    <span class="n">qmparameter_temp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="p">)</span>
    <span class="n">file_mol</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">QM_file_localization_name</span> <span class="p">,</span> <span class="s1">&#39;molecule.mol&#39;</span><span class="p">)</span>
    <span class="n">dalton_manager_module</span><span class="o">.</span><span class="n">generate_inp_mol</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="p">,</span> <span class="n">file_mol</span><span class="p">,</span> <span class="n">qmdescription</span><span class="p">,</span> <span class="n">message_1</span><span class="o">=</span><span class="s1">&#39;Laboratory frame&#39;</span><span class="p">)</span> 
    
        <span class="c1"># Static Electrostatic:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qmparameter_temp</span><span class="o">.</span><span class="n">static_electric_field</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">qmparameter_temp</span><span class="o">.</span><span class="n">static_electric_field_direction</span> <span class="o">==</span> <span class="s1">&#39;Molecular&#39;</span><span class="p">:</span> <span class="c1"># the value of the electrostatic field should be rotated in the molecular frame</span>
            <span class="n">qmparameter_temp</span><span class="o">.</span><span class="n">static_electric_field</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">rotate_1st_order_tensor</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_molecule</span><span class="p">[</span><span class="n">kkk</span><span class="o">-</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;rot_mat&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">qmparameter_temp</span><span class="o">.</span><span class="n">static_electric_field</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
            <span class="c1"># external_electric_field = qmparameter_temp.static_electric_field</span>
            
    <span class="c1"># Initialize the electrostatic description:</span>
    <span class="n">electro_description</span> <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">()</span>
    
    <span class="n">L_E_long_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">L_dE_long_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    
    <span class="c1"># rcut_PE_direct = moleculetype.mtparameter.optparameter.qmparameter.rcut_PE_direct</span>
    <span class="c1"># rcut_PE_smoth = moleculetype.mtparameter.optparameter.qmparameter.rcut_PE_smoth</span>
    <span class="c1"># ewald_screaning = moleculetype.mtparameter.optparameter.qmparameter.ewald_factor</span>
    <span class="n">L_box_vector</span> <span class="o">=</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">L_k_vector</span><span class="o">*</span><span class="n">L_box_size</span>
    
    <span class="c1"># for K in range(0, GP.nbr_type_molecule, 1): #iteration over the molecule type</span>
    <span class="c1">#    moleculetype = L_moleculetype[K]</span>
    <span class="c1"># Try for every molecule of the box if they can be a acceptable position usiung the PBC condition: (acceptable position means that the molecule distance from the target molecule is smaller then max_distance.)</span>
    <span class="k">for</span> <span class="n">molecule_type_rep</span> <span class="ow">in</span> <span class="n">GP</span><span class="o">.</span><span class="n">L_mt_key_mt</span><span class="p">:</span> <span class="c1"># Goes over all the molecule type</span>
        <span class="n">name_neigh_temp</span> <span class="o">=</span> <span class="n">molecule_type_rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">module_neigh_temp</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">toolbox</span><span class="o">.</span><span class="n">creat_name_for_MT_module_load</span><span class="p">(</span><span class="n">name_neigh_temp</span><span class="p">))</span>
        <span class="n">smparameter</span> <span class="o">=</span> <span class="n">module_neigh_temp</span><span class="o">.</span><span class="n">info_molecule</span><span class="p">(</span><span class="n">SingleMoleculeParameter</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">res_neigh</span> <span class="ow">in</span> <span class="n">molecule_type_rep</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># goes over all the molecule of the molecule type</span>
            <span class="n">L_pos_neigh</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s2">&quot;resid &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">))</span><span class="o">.</span><span class="n">positions</span>
            <span class="n">L_pos_neigh</span> <span class="o">=</span> <span class="n">geometry_manager</span><span class="o">.</span><span class="n">check_molecule_geometry</span><span class="p">(</span><span class="n">smparameter</span><span class="p">,</span> <span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">)</span> <span class="c1">#make sure the molecule is not cutted by PBC condition</span>
            <span class="n">L_pos_neigh_mean</span> <span class="o">=</span> <span class="n">module_neigh_temp</span><span class="o">.</span><span class="n">compute_mean_position</span><span class="p">(</span><span class="n">L_pos_neigh</span><span class="p">)</span>
            
            <span class="n">shift</span> <span class="o">=</span> <span class="n">geometry_manager</span><span class="o">.</span><span class="n">find_closest_position_threw_pbc</span><span class="p">(</span><span class="n">L_target_mean_pos</span><span class="p">,</span> <span class="n">L_pos_neigh_mean</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">,</span> <span class="n">GP</span><span class="o">.</span><span class="n">env_authorised_pbc_condition</span><span class="p">)</span> <span class="o">-</span> <span class="n">L_target_mean_pos</span>
            <span class="n">L_pos_neigh_mean_centered</span> <span class="o">=</span>  <span class="n">L_pos_neigh_mean</span> <span class="o">+</span> <span class="n">shift</span>
            <span class="n">L_pos_neigh_centered</span> <span class="o">=</span> <span class="n">L_pos_neigh</span> <span class="o">+</span> <span class="n">shift</span>
            
            <span class="n">distance_from_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">L_pos_neigh_mean_centered</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            
            <span class="n">electro_description_single_neigh</span> <span class="o">=</span> <span class="n">module_neigh_temp</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">L_pos_neigh_centered</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">distance_from_target</span> <span class="o">&lt;</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">rcut_PE_direct</span><span class="p">:</span>
                <span class="c1"># we want to avoid the case of self direct interaction, if the mean position in the centered frame are the same, it means that it is the same molecule (or the MD has a big problem):</span>
                <span class="k">if</span> <span class="n">distance_from_target</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">):</span> <span class="c1"># in Angstrom </span>
                    <span class="n">electro_description</span><span class="o">.</span><span class="n">merge_mol</span><span class="p">(</span><span class="n">electro_description_single_neigh</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">distance_from_target</span> <span class="o">&lt;</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">rcut_PE_smoth</span><span class="p">:</span>
                    <span class="c1"># rescaling factor for this molecule:</span>
                    <span class="n">rescaling_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">distance_from_target</span><span class="o">/</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">ewald_factor</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="c1"># sommation over k, the zero with rescaling</span>
                    <span class="c1"># print(&#39;rescaling:&#39;, distance_from_target, rescaling_charges, res_neigh)</span>
                    <span class="c1">#E_t =  electric_field_module.add_single_contribution_electric_field_pbc(electro_description_single_neigh)</span>
                    <span class="c1">#E_t_long =  electric_field_module.add_single_contribution_electric_field_pbc(electro_description_single_neigh)*(1-rescaling_charges)</span>
                    <span class="n">E_long_range</span><span class="p">,</span> <span class="n">dE_long_range</span> <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">add_single_contribution_electric_field_pbc</span><span class="p">(</span><span class="n">electro_description_single_neigh</span><span class="p">)</span>
                    <span class="n">L_E_long_range</span> <span class="o">=</span> <span class="n">L_E_long_range</span> <span class="o">+</span> <span class="n">E_long_range</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rescaling_charges</span><span class="p">)</span>
                    <span class="n">L_dE_long_range</span> <span class="o">=</span> <span class="n">L_dE_long_range</span> <span class="o">+</span> <span class="n">dE_long_range</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rescaling_charges</span><span class="p">)</span> 
                        
                    <span class="c1"># add to direct calculation with rescaling</span>
                    <span class="n">electro_description_single_neigh</span><span class="o">.</span><span class="n">rescale_values</span><span class="p">(</span><span class="n">rescaling_charges</span><span class="p">)</span>
                    <span class="c1">#E_t_short =  electric_field_module.add_single_contribution_electric_field_pbc(electro_description_single_neigh)</span>
                    <span class="c1">#print(E_t_short/E_t, rescaling_charges, E_t_short+E_t_long-E_t)</span>
                    <span class="n">electro_description</span><span class="o">.</span><span class="n">merge_mol</span><span class="p">(</span><span class="n">electro_description_single_neigh</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># not in the direct calculation: the molecule is added to the electrostati field generated.</span>
                    <span class="n">E_long_range</span><span class="p">,</span> <span class="n">dE_long_range</span> <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">add_single_contribution_electric_field_pbc</span><span class="p">(</span><span class="n">electro_description_single_neigh</span><span class="p">)</span>
                    <span class="n">L_E_long_range</span> <span class="o">=</span> <span class="n">L_E_long_range</span> <span class="o">+</span> <span class="n">E_long_range</span> 
                    <span class="n">L_dE_long_range</span> <span class="o">=</span> <span class="n">L_dE_long_range</span> <span class="o">+</span> <span class="n">dE_long_range</span> 
                            
            <span class="c1"># to avoid any trouble with respect to the rescaling procedure or the merging procedure: </span>
            <span class="n">electro_description_single_neigh</span> <span class="o">=</span> <span class="n">module_neigh_temp</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">L_pos_neigh_centered</span><span class="p">)</span>    
            <span class="c1"># summing over all the images accross the duplicated box</span>
            <span class="n">E_long_range</span><span class="p">,</span> <span class="n">dE_long_range</span> <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">add_single_contribution_electric_field_pbc</span><span class="p">(</span><span class="n">electro_description_single_neigh</span><span class="p">,</span> <span class="n">L_box_vector</span><span class="o">=</span><span class="n">L_box_vector</span><span class="p">)</span>
            <span class="n">L_E_long_range</span> <span class="o">=</span> <span class="n">L_E_long_range</span> <span class="o">+</span> <span class="n">E_long_range</span> 
            <span class="n">L_dE_long_range</span> <span class="o">=</span> <span class="n">L_dE_long_range</span> <span class="o">+</span> <span class="n">dE_long_range</span> 
    
    
    <span class="c1"># DALTON input file: with the long range electric field</span>
    <span class="n">file_to_creat_dal</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">QM_file_localization_name</span> <span class="p">,</span> <span class="s1">&#39;dalton.dal&#39;</span><span class="p">)</span>            
    <span class="n">dalton_manager_module</span><span class="o">.</span><span class="n">generate_inp_dal</span><span class="p">(</span><span class="n">qmparameter_temp</span><span class="p">,</span> <span class="n">file_to_creat_dal</span><span class="p">,</span> <span class="n">molecular_electric_field</span><span class="o">=</span><span class="n">L_E_long_range</span><span class="p">)</span> <span class="c1"># here we use qmparameter_temp instead of moleculetype.mtparameter.optparameter.qmparameter because it contains the static electric field that can be writen in the molecular frame     </span>
    
    
    <span class="c1"># Write the .pot file and the .xyz file if asked. This part should be done before the dalton_manager_module.generate_inp_pot call</span>
    <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">write_xyz_environment</span><span class="p">:</span>
        <span class="n">nbr_atom_total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_mol_target</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">electro_description</span><span class="o">.</span><span class="n">L_localization_type</span><span class="p">)</span>
        <span class="n">toolbox</span><span class="o">.</span><span class="n">write_xyz_mol</span><span class="p">(</span><span class="n">nbr_atom_total</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;X&#39;</span> <span class="k">for</span> <span class="n">K</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_mol_target</span><span class="p">),</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">pos_mol_target</span><span class="o">-</span><span class="n">L_target_mean_pos</span><span class="p">,</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">QM_file_localization_name</span><span class="p">,</span> <span class="s1">&#39;potential.xyz&#39;</span><span class="p">),</span> <span class="n">type_writting</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    
    <span class="c1"># POTENTIAL input file:</span>
    <span class="n">file_pe</span> <span class="o">=</span> <span class="n">toolbox</span><span class="o">.</span><span class="n">concatenate_path</span><span class="p">(</span><span class="n">QM_file_localization_name</span><span class="p">,</span> <span class="s1">&#39;potential.pot&#39;</span><span class="p">)</span>
    <span class="n">dalton_manager_module</span><span class="o">.</span><span class="n">generate_inp_pot</span><span class="p">(</span><span class="n">electro_description</span><span class="p">,</span> <span class="n">file_pe</span><span class="p">,</span> <span class="n">xyz_environemnt</span><span class="o">=</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">write_xyz_environment</span><span class="p">)</span>         
    
    <span class="c1"># Compute the electric field felt by the molecul generated by the PE environment:</span>
    <span class="k">if</span> <span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">compute_electric_field_PE</span><span class="p">:</span>   
        <span class="n">L_E_long_range</span> <span class="o">=</span> <span class="n">L_E_long_range</span><span class="o">*</span><span class="mf">51.42206747</span> <span class="c1"># in V/A</span>
        <span class="n">L_dE_long_range</span> <span class="o">=</span> <span class="n">L_dE_long_range</span><span class="o">*</span><span class="mf">97.17362428</span> <span class="c1"># in V/A^2 , the reason it is not the same as the electric field is because the length unit is bohr.</span>
        <span class="n">electric_field_direct_lab</span><span class="p">,</span> <span class="n">d_electric_field_direct_lab</span>  <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">compute_electric_field_from_electro_description</span><span class="p">(</span><span class="n">electro_description</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># the molecule is centered at [0, 0, 0]</span>
        
        <span class="n">L_value_electric_field</span> <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">to_store_electric_field</span><span class="p">(</span><span class="n">electric_field_direct_lab</span><span class="p">,</span> <span class="n">d_electric_field_direct_lab</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_molecule</span><span class="p">[</span><span class="n">kkk</span><span class="o">-</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;rot_mat&#39;</span><span class="p">),</span> <span class="n">style</span><span class="o">=</span><span class="s1">&#39;direct+long&#39;</span><span class="p">,</span> <span class="n">E_long</span><span class="o">=</span><span class="n">L_E_long_range</span><span class="p">,</span> <span class="n">dE_long</span><span class="o">=</span><span class="n">L_dE_long_range</span><span class="p">)</span>
        <span class="n">name_attr_electric_field</span> <span class="o">=</span> <span class="s1">&#39;electric_field_PE&#39;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_molecule</span><span class="p">[</span><span class="n">kkk</span><span class="o">-</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">name_attr_electric_field</span><span class="p">,</span> <span class="n">L_value_electric_field</span><span class="p">)</span> 
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PE LONG:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">kkk</span><span class="o">-</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">name_attr_electric_field</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;direct&#39;</span><span class="p">,</span> <span class="n">L_value_electric_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;long&#39;</span><span class="p">,</span> <span class="n">L_value_electric_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">L_value_electric_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">L_value_electric_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">])</span>
        
    <span class="c1">############################## TRY SOLVER ##################################################</span>
    <span class="c1">############################## TRY SOLVER ##################################################</span>
    <span class="c1">############################## TRY SOLVER ##################################################</span>
    <span class="c1">############################## TRY SOLVER ##################################################</span>
    
    <span class="c1">###### construction electrostatic map</span>
    <span class="n">L_charge_pos</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L_charge_value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">molecule_type_rep</span> <span class="ow">in</span> <span class="n">GP</span><span class="o">.</span><span class="n">L_mt_key_mt</span><span class="p">:</span> <span class="c1"># Goes over all the molecule type</span>
        <span class="n">name_neigh_temp</span> <span class="o">=</span> <span class="n">molecule_type_rep</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">module_neigh_temp</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">toolbox</span><span class="o">.</span><span class="n">creat_name_for_MT_module_load</span><span class="p">(</span><span class="n">name_neigh_temp</span><span class="p">))</span>
        <span class="n">smparameter</span> <span class="o">=</span> <span class="n">module_neigh_temp</span><span class="o">.</span><span class="n">info_molecule</span><span class="p">(</span><span class="n">SingleMoleculeParameter</span><span class="p">())</span>
        
        <span class="c1"># first molecule to try:</span>
        <span class="n">res_neigh</span> <span class="o">=</span> <span class="n">molecule_type_rep</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">L_pos_neigh</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s2">&quot;resid &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">))</span><span class="o">.</span><span class="n">positions</span>
        <span class="n">L_pos_neigh</span> <span class="o">=</span> <span class="n">geometry_manager</span><span class="o">.</span><span class="n">check_molecule_geometry</span><span class="p">(</span><span class="n">smparameter</span><span class="p">,</span> <span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">)</span> <span class="c1">#make sure the molecule is not cutted by PBC condition</span>
        <span class="n">electro_description_single_neigh</span> <span class="o">=</span> <span class="n">module_neigh_temp</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">L_pos_neigh</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">electro_description_single_neigh</span><span class="o">.</span><span class="n">L_charge_order_0</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># this MT should be added</span>
            <span class="n">n_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">electro_description_single_neigh</span><span class="o">.</span><span class="n">L_charge_order_0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">res_neigh</span> <span class="ow">in</span> <span class="n">molecule_type_rep</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># goes over all the molecule of the molecule type</span>
                <span class="n">L_pos_neigh</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s2">&quot;resid &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">))</span><span class="o">.</span><span class="n">positions</span>
                <span class="n">L_pos_neigh</span> <span class="o">=</span> <span class="n">geometry_manager</span><span class="o">.</span><span class="n">check_molecule_geometry</span><span class="p">(</span><span class="n">smparameter</span><span class="p">,</span> <span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">)</span> <span class="c1">#make sure the molecule is not cutted by PBC condition</span>
                <span class="n">electro_description_single_neigh</span> <span class="o">=</span> <span class="n">module_neigh_temp</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">L_pos_neigh</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">III</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pos</span><span class="p">):</span>
                    <span class="n">pos_of_the_charge</span><span class="p">,</span> <span class="n">value_of_the_charge</span> <span class="o">=</span> <span class="n">electro_description_single_neigh</span><span class="o">.</span><span class="n">L_charge_order_0</span><span class="p">[</span><span class="n">III</span><span class="p">]</span>
                    <span class="n">L_charge_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">electro_description_single_neigh</span><span class="o">.</span><span class="n">L_localization_site</span><span class="p">[</span><span class="n">pos_of_the_charge</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
                    <span class="n">L_charge_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_of_the_charge</span><span class="p">)</span>
                                        
    
    <span class="c1">###### solver</span>
    <span class="kn">from</span> <span class="nn">Frog.electrostatic_potential_solver</span> <span class="kn">import</span> <span class="n">ElectrostaticPotentialSolver</span>
    
    <span class="n">L_charge_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_charge_pos</span><span class="p">)</span>
    <span class="n">L_charge_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_charge_value</span><span class="p">)</span>
    
    <span class="n">solver</span> <span class="o">=</span> <span class="n">ElectrostaticPotentialSolver</span><span class="p">(</span><span class="n">L_charge_pos</span><span class="p">,</span> <span class="n">L_charge_value</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">)</span>
    <span class="c1">#solver.set_parameter(&#39;k_cutoff&#39;, 2.0)</span>
    <span class="c1">#solver.set_parameter(&#39;gaussian_width&#39;, 0.5)</span>
    <span class="c1">#solver.set_parameter(&#39;gaussian_cutoff&#39;, 6.0)</span>
    
    <span class="n">solver</span><span class="o">.</span><span class="n">set_parameter</span><span class="p">(</span><span class="s1">&#39;k_cutoff&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_parameter</span><span class="p">(</span><span class="s1">&#39;gaussian_width&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_parameter</span><span class="p">(</span><span class="s1">&#39;gaussian_cutoff&#39;</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">)</span>

    
    <span class="n">solver</span><span class="o">.</span><span class="n">solve_potential</span><span class="p">()</span>
    
    <span class="c1">###### at the given molecule</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">charge</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_data_grid</span><span class="p">(</span><span class="s1">&#39;charge&#39;</span><span class="p">)</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_data_grid</span><span class="p">(</span><span class="s1">&#39;efield_x&#39;</span><span class="p">)</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">ey</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_data_grid</span><span class="p">(</span><span class="s1">&#39;efield_y&#39;</span><span class="p">)</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">ez</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_data_grid</span><span class="p">(</span><span class="s1">&#39;efield_z&#39;</span><span class="p">)</span>
    <span class="n">L_axis_xyz_solver</span> <span class="o">=</span> <span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">]</span>


    <span class="n">L_xyz_of_interest</span> <span class="o">=</span> <span class="n">L_target_mean_pos</span>
    <span class="n">L_xyz_of_interest_new</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">L_index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">L_index</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">closest_idx</span><span class="p">(</span><span class="n">L_axis_xyz_solver</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">L_xyz_of_interest</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">L_xyz_of_interest_new</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_axis_xyz_solver</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">L_index</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
        
    <span class="c1">#for k in range(3):</span>
    <span class="c1">#    print(L_index[k])</span>
    <span class="c1">#    print(L_axis_xyz_solver[k][L_index[k]], L_xyz_of_interest[k])</span>
    <span class="c1">#print(L_xyz_of_interest_new, L_xyz_of_interest)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; CHARGE:&#39;</span><span class="p">,</span> <span class="n">L_xyz_of_interest_new</span><span class="p">,</span> <span class="n">charge</span><span class="p">[</span><span class="n">L_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
   
    <span class="n">L_e_solver</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ex</span><span class="p">[</span><span class="n">L_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">ey</span><span class="p">[</span><span class="n">L_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">ez</span><span class="p">[</span><span class="n">L_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solver total:&#39;</span><span class="p">,</span> <span class="n">L_e_solver</span><span class="p">)</span>
    
    
    <span class="c1">###### short and long part</span>
    <span class="c1"># We have already the short range contribution, but without the target molecule one</span>
    <span class="c1"># In the solver there are all the contribution, including the target molecule</span>
    <span class="c1"># so we have to compute the target molecule contribution at the same place:</span>
    <span class="n">electro_description_self</span> <span class="o">=</span> <span class="n">molecule_type_module</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">pos_mol_target</span><span class="p">)</span>
    
        
    <span class="n">electric_field_self_lab</span><span class="p">,</span> <span class="n">d_electric_field_self_lab</span>  <span class="o">=</span> <span class="n">Frog</span><span class="o">.</span><span class="n">electric_field_module</span><span class="o">.</span><span class="n">compute_electric_field_from_electro_description</span><span class="p">(</span><span class="n">electro_description_self</span><span class="p">,</span> <span class="n">L_xyz_of_interest_new</span><span class="p">)</span> <span class="c1"># should be in V/A</span>
    
    
    <span class="c1">##### other try for short and long range:</span>
    <span class="c1"># create a new solver for the short range + target molecule</span>
    <span class="c1"># electro_description is the short range part in the molecule frame</span>
    
    <span class="c1"># add the target molecule</span>
    <span class="n">electro_description_self_for_direct</span> <span class="o">=</span> <span class="n">molecule_type_module</span><span class="o">.</span><span class="n">electrostatic_description</span><span class="p">(</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">mtparameter</span><span class="o">.</span><span class="n">optparameter</span><span class="o">.</span><span class="n">qmparameter</span><span class="o">.</span><span class="n">pe_level</span><span class="p">,</span> <span class="n">Frog</span><span class="o">.</span><span class="n">class_OpticalParameter</span><span class="o">.</span><span class="n">ElectrostaticDescription</span><span class="p">(),</span> <span class="n">L_pos</span><span class="o">=</span><span class="n">pos_mol_target</span><span class="o">-</span><span class="n">L_target_mean_pos</span><span class="p">)</span>
    <span class="n">electro_description</span><span class="o">.</span><span class="n">merge_mol</span><span class="p">(</span><span class="n">electro_description_self_for_direct</span><span class="p">)</span>
    <span class="c1"># create the pos and charge for solver</span>
    <span class="n">L_charge_pos</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L_charge_value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">electro_description</span><span class="o">.</span><span class="n">L_charge_order_0</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># this MT should be added</span>
        <span class="n">n_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">electro_description</span><span class="o">.</span><span class="n">L_charge_order_0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">III</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pos</span><span class="p">):</span>
            <span class="n">pos_of_the_charge</span><span class="p">,</span> <span class="n">value_of_the_charge</span> <span class="o">=</span> <span class="n">electro_description</span><span class="o">.</span><span class="n">L_charge_order_0</span><span class="p">[</span><span class="n">III</span><span class="p">]</span>
            <span class="n">L_charge_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">electro_description</span><span class="o">.</span><span class="n">L_localization_site</span><span class="p">[</span><span class="n">pos_of_the_charge</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">L_target_mean_pos</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span>
            <span class="n">L_charge_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value_of_the_charge</span><span class="p">)</span>
    <span class="c1"># solve the direct system with PBC</span>
    <span class="n">L_charge_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_charge_pos</span><span class="p">)</span>
    <span class="n">L_charge_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_charge_value</span><span class="p">)</span>
    
    <span class="n">solver</span> <span class="o">=</span> <span class="n">ElectrostaticPotentialSolver</span><span class="p">(</span><span class="n">L_charge_pos</span><span class="p">,</span> <span class="n">L_charge_value</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">)</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_parameter</span><span class="p">(</span><span class="s1">&#39;k_cutoff&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_parameter</span><span class="p">(</span><span class="s1">&#39;gaussian_width&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">set_parameter</span><span class="p">(</span><span class="s1">&#39;gaussian_cutoff&#39;</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">)</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">solve_potential</span><span class="p">()</span>
    
    <span class="c1"># at the given molecule</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">ex</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_data_grid</span><span class="p">(</span><span class="s1">&#39;efield_x&#39;</span><span class="p">)</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">ey</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_data_grid</span><span class="p">(</span><span class="s1">&#39;efield_y&#39;</span><span class="p">)</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">ez</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">get_data_grid</span><span class="p">(</span><span class="s1">&#39;efield_z&#39;</span><span class="p">)</span>
    <span class="n">L_axis_xyz_solver</span> <span class="o">=</span> <span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">]</span>

    <span class="n">L_xyz_of_interest</span> <span class="o">=</span> <span class="n">L_target_mean_pos</span>
    <span class="n">L_xyz_of_interest_new_direct</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">L_index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">L_index</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">closest_idx</span><span class="p">(</span><span class="n">L_axis_xyz_solver</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">L_xyz_of_interest</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">L_xyz_of_interest_new_direct</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_axis_xyz_solver</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">L_index</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span>
        
    <span class="c1">#for k in range(3):</span>
    <span class="c1">#    print(L_index[k])</span>
    <span class="c1">#    print(L_axis_xyz_solver[k][L_index[k]], L_xyz_of_interest[k])</span>
    <span class="c1">#print(L_xyz_of_interest_new, L_xyz_of_interest)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; should be equal!&#39;</span><span class="p">,</span> <span class="n">L_xyz_of_interest_new</span><span class="p">,</span> <span class="n">L_xyz_of_interest_new_direct</span><span class="p">)</span>
   
    <span class="n">L_e_solver_direct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ex</span><span class="p">[</span><span class="n">L_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">ey</span><span class="p">[</span><span class="n">L_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">ez</span><span class="p">[</span><span class="n">L_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">L_index</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>
    
    
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;PE LONG:&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">kkk</span><span class="o">-</span><span class="n">moleculetype</span><span class="o">.</span><span class="n">L_key_mol</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">name_attr_electric_field</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;direct&#39;</span><span class="p">,</span> <span class="n">L_value_electric_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;long&#39;</span><span class="p">,</span> <span class="n">L_value_electric_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">L_value_electric_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">L_value_electric_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">])</span>
    
    
    <span class="n">e_solver_long</span> <span class="o">=</span> <span class="n">L_e_solver</span><span class="o">-</span><span class="n">electric_field_self_lab</span><span class="o">-</span> <span class="n">L_value_electric_field</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solver:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solver self:&#39;</span><span class="p">,</span> <span class="n">electric_field_self_lab</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solver total total:&#39;</span><span class="p">,</span> <span class="n">L_e_solver</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solver direct&#39;</span><span class="p">,</span> <span class="n">L_e_solver_direct</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solver total - self:&#39;</span><span class="p">,</span> <span class="n">L_e_solver</span><span class="o">-</span><span class="n">electric_field_self_lab</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solver total - solver direct:&#39;</span><span class="p">,</span> <span class="n">L_e_solver</span><span class="o">-</span><span class="n">L_e_solver_direct</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Solver long frog:&#39;</span><span class="p">,</span> <span class="n">e_solver_long</span><span class="p">)</span></div>

      
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="environement_builder_return_position">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.environement_builder_return_position">[docs]</a>
<span class="k">def</span> <span class="nf">environement_builder_return_position</span><span class="p">(</span><span class="n">residue_nbr</span><span class="p">,</span> <span class="n">mean_position</span><span class="p">,</span> <span class="n">target_molecule_type_module</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">pbc</span><span class="p">,</span> <span class="n">L_name_partner</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">just_number_mol</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the position centered around the molecule number &#39;&#39;residue_nbr&#39;&#39; up to a distance &#39;&#39;max_distance&#39;&#39;. This is done in 2 steps: </span>
<span class="sd">        First find the &#39;&#39;first shell&#39;&#39; of neighbors number up to the max_distance. This uses the PBC condition in all the direction.</span>
<span class="sd">        Check that these neighbors are allowed using the specific PBC restriction. Then, duplicate them using the PBC condition if needed. The output is the position of the neigbors in the target molecule frame. </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1">#</span>
    <span class="n">L_box_size</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">L_box_size</span>

    <span class="c1"># 1st step: Find the first shell neighborgs number:</span>
    <span class="n">L_list_name_MT</span><span class="p">,</span> <span class="n">L_neighbourhood_names_number</span> <span class="o">=</span> <span class="n">built_environment_first_shell_number</span><span class="p">(</span><span class="n">residue_nbr</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">L_name_partner</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_list_name_MT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">just_number_mol</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">L_list_name_MT</span><span class="p">,</span> <span class="n">L_neighbourhood_names_number</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    
    <span class="c1"># 2nd step: check the neighbors position and duplicate them if needed. </span>
    <span class="n">L_neighbourhood_names_number_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L_environment</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#print(&#39;env fun, list MT neigh:&#39;, L_list_name_MT)</span>
    <span class="c1">#print(&#39;env fun, list neigh:&#39;, L_neighbourhood_names_number)</span>
    <span class="k">for</span> <span class="n">K_MT_name</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_list_name_MT</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1">#print(&#39;env fun, adding:&#39;, L_list_name_MT[K_MT_name], K_MT_name)</span>
        <span class="n">L_neighbourhood_names_number_new</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">name_neigh_temp</span> <span class="o">=</span> <span class="n">L_list_name_MT</span><span class="p">[</span><span class="n">K_MT_name</span><span class="p">]</span>
        <span class="n">module_neigh_temp</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">import_module</span><span class="p">(</span><span class="n">toolbox</span><span class="o">.</span><span class="n">creat_name_for_MT_module_load</span><span class="p">(</span><span class="n">name_neigh_temp</span><span class="p">))</span>
        <span class="n">smparameter</span> <span class="o">=</span> <span class="n">module_neigh_temp</span><span class="o">.</span><span class="n">info_molecule</span><span class="p">(</span><span class="n">SingleMoleculeParameter</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">res_neigh</span> <span class="ow">in</span> <span class="n">L_neighbourhood_names_number</span><span class="p">[</span><span class="n">K_MT_name</span><span class="p">]:</span> <span class="c1"># goes over the neighborgs molecule of this molecule type</span>
            <span class="n">L_molecule_neigh_toadd</span> <span class="o">=</span> <span class="n">single_neighbour_return_position</span><span class="p">(</span><span class="n">residue_nbr</span><span class="p">,</span> <span class="n">mean_position</span><span class="p">,</span> <span class="n">res_neigh</span><span class="p">,</span> <span class="n">module_neigh_temp</span><span class="p">,</span> <span class="n">smparameter</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">pbc</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_molecule_neigh_toadd</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span> <span class="p">:</span>
                <span class="k">for</span> <span class="n">trotter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_molecule_neigh_toadd</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">L_environment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_molecule_neigh_toadd</span><span class="p">[</span><span class="n">trotter</span><span class="p">]))</span>
                    <span class="n">L_neighbourhood_names_number_new</span><span class="p">[</span><span class="n">K_MT_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">L_list_name_MT</span><span class="p">,</span> <span class="n">L_neighbourhood_names_number_new</span><span class="p">,</span> <span class="n">L_environment</span><span class="p">)</span></div>

    
<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="built_environment_first_shell_number">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.built_environment_first_shell_number">[docs]</a>
<span class="k">def</span> <span class="nf">built_environment_first_shell_number</span><span class="p">(</span><span class="n">residue_nbr</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">L_name_partner</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    TODO</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#MDAnalysis.core.flags[&#39;use_periodic_selections&#39;] = True</span>
    <span class="c1">#MDAnalysis.core.flags[&#39;use_KDTree_routines&#39;] = False</span>
    <span class="n">ag_updating</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s2">&quot;around &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">max_distance</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; resid &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">residue_nbr</span><span class="p">),</span> <span class="n">updating</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="n">L_neighbourhood</span> <span class="o">=</span> <span class="n">ag_updating</span><span class="o">.</span><span class="n">resids</span>
    <span class="n">L_neighbourhood</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_neighbourhood</span><span class="p">,</span> <span class="n">residue_nbr</span><span class="p">)</span> <span class="c1"># Add the target molecule itself. It will be remove it is irrelevent (ie not PBC images of itself fulfies the distance condition</span>
    
    <span class="n">L_list_name_MT</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L_neighbourhood_names_number</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_name_partner</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">L_name_partner</span><span class="p">:</span> <span class="c1"># look for all the possible partner molecule</span>
        <span class="k">for</span> <span class="n">res_neigh</span> <span class="ow">in</span> <span class="n">L_neighbourhood</span><span class="p">:</span>
            <span class="n">name_neigh</span> <span class="o">=</span> <span class="n">GP</span><span class="o">.</span><span class="n">find_molecule_type</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_list_name_MT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">name_neigh</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">L_list_name_MT</span><span class="p">:</span>
                <span class="n">L_list_name_MT</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name_neigh</span><span class="p">)</span>
                <span class="n">L_neighbourhood_names_number</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">L_neighbourhood_names_number</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">res_neigh</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">L_neighbourhood_names_number</span><span class="p">[</span><span class="n">L_list_name_MT</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name_neigh</span><span class="p">)]:</span>
                    <span class="n">L_neighbourhood_names_number</span><span class="p">[</span><span class="n">L_list_name_MT</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name_neigh</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">)</span>
                    
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">L_name_partner</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span> <span class="c1"># Looking only for a specific molecule type</span>
        <span class="c1"># What are the number of the molecule with the target name: </span>
        <span class="n">L_list_name_MT</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_name_partner</span><span class="p">)</span>
        <span class="c1">#for ttt in GP.L_mt_key_mt:</span>
        <span class="c1">#    if ttt[0] == L_name_partner:</span>
        <span class="c1">#        L_key_mol_partner = ttt[1]</span>
        <span class="c1">#        L_list_name_MT.append(ttt[0])</span>
        <span class="c1">#        L_neighbourhood_names_number.append([])</span>
        <span class="k">for</span> <span class="n">res_neigh</span> <span class="ow">in</span> <span class="n">L_neighbourhood</span><span class="p">:</span>
            <span class="n">name_neigh</span> <span class="o">=</span> <span class="n">GP</span><span class="o">.</span><span class="n">find_molecule_type</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">)</span>
            <span class="n">L_neighbourhood_names_number</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="k">if</span> <span class="n">name_neigh</span> <span class="o">==</span> <span class="n">L_name_partner</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">res_neigh</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">L_neighbourhood_names_number</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># Here only one neigh MT.</span>
                    <span class="n">L_neighbourhood_names_number</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">)</span>
                <span class="c1">#if res_neigh &lt;= L_key_mol_partner[-1] and res_neigh &gt;= L_key_mol_partner[0]:</span>
                <span class="c1">#    L_neighbourhood_names_number[0].append(res_neigh)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_neighbourhood_names_number</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">#return nothing as expected</span>
            <span class="n">L_list_name_MT</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">L_neighbourhood_names_number</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;WARNING: Strange case, please check the L_name_partner optional parameter&#39;</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">L_list_name_MT</span><span class="p">,</span> <span class="n">L_neighbourhood_names_number</span><span class="p">)</span></div>

    

<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="single_neighbour_return_position">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.single_neighbour_return_position">[docs]</a>
<span class="k">def</span> <span class="nf">single_neighbour_return_position</span><span class="p">(</span><span class="n">residue_nbr</span><span class="p">,</span> <span class="n">mean_position</span><span class="p">,</span> <span class="n">res_neigh</span><span class="p">,</span> <span class="n">module_neigh_temp</span><span class="p">,</span> <span class="n">smparameter</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">pbc</span><span class="p">):</span>

    <span class="n">L_box_size</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">L_box_size</span>
    <span class="n">L_movment_environment_building_pbc</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">L_movment_environment_building_pbc</span>
    <span class="n">L_molecule_neigh_toadd</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L_pos_neigh</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">select_atoms</span><span class="p">(</span><span class="s2">&quot;resid &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">res_neigh</span><span class="p">))</span><span class="o">.</span><span class="n">positions</span>
    <span class="n">L_pos_neigh</span> <span class="o">=</span> <span class="n">geometry_manager</span><span class="o">.</span><span class="n">check_molecule_geometry</span><span class="p">(</span><span class="n">smparameter</span><span class="p">,</span> <span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">)</span> <span class="c1">#make sure the molecule is not cutted by PBC condition</span>
    <span class="n">L_pos_neigh_mean</span> <span class="o">=</span> <span class="n">module_neigh_temp</span><span class="o">.</span><span class="n">compute_mean_position</span><span class="p">(</span><span class="n">L_pos_neigh</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">GP</span><span class="o">.</span><span class="n">env_authorised_pbc_condition</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">GP</span><span class="o">.</span><span class="n">env_authorised_pbc_condition</span><span class="p">:</span> <span class="c1">#no PBC condition can be used in order to increased the neighorhood size.</span>
        <span class="k">if</span> <span class="n">res_neigh</span> <span class="o">!=</span> <span class="n">residue_nbr</span><span class="p">:</span> <span class="c1"># if no PBC uses are allowed, the target molecule cannot be a neigbours of itself!</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">mean_position</span><span class="o">-</span><span class="n">L_pos_neigh_mean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">max_distance</span><span class="p">:</span> <span class="c1"># this extra test is made in order to ensure that no PBC condition is used reduce the distance between the target and this neighbors. Indeed, in the first part, MDAnalysis uses all the PBC condition possible.</span>
                <span class="c1"># L_pos_neigh_centered = centering_position_neighbourg(L_pos_neigh, mean_position, max_distance, smparameter, L_box_size)</span>
                <span class="n">L_pos_neigh_centered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_pos_neigh</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">atom_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L_pos_neigh_centered</span><span class="p">)):</span>
                    <span class="n">L_pos_neigh_centered</span><span class="p">[</span><span class="n">atom_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_pos_neigh_centered</span><span class="p">[</span><span class="n">atom_number</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span> <span class="o">-</span> <span class="n">mean_position</span>
                <span class="n">L_molecule_neigh_toadd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_pos_neigh_centered</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">L_position_possible</span> <span class="o">=</span> <span class="n">single_neighbour_find_position_PBC</span><span class="p">(</span><span class="n">residue_nbr</span><span class="p">,</span> <span class="n">mean_position</span><span class="p">,</span> <span class="n">res_neigh</span><span class="p">,</span> <span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">L_pos_neigh_mean</span><span class="p">,</span> <span class="n">smparameter</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">L_movment_environment_building_pbc</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_position_possible</span><span class="p">)</span> <span class="o">!=</span><span class="mi">0</span> <span class="p">:</span>
            <span class="k">for</span> <span class="n">trotter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_position_possible</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">L_molecule_neigh_toadd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_position_possible</span><span class="p">[</span><span class="n">trotter</span><span class="p">]))</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">L_molecule_neigh_toadd</span><span class="p">)</span></div>


<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="single_neighbour_find_position_PBC">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.single_neighbour_find_position_PBC">[docs]</a>
<span class="k">def</span> <span class="nf">single_neighbour_find_position_PBC</span><span class="p">(</span><span class="n">residue_nbr</span><span class="p">,</span> <span class="n">mean_position</span><span class="p">,</span> <span class="n">res_neigh</span><span class="p">,</span> <span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">L_pos_neigh_mean</span><span class="p">,</span> <span class="n">smparameter</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">GP</span><span class="p">,</span> <span class="n">L_movement</span><span class="p">):</span>
        
    <span class="c1"># Try for if they can be a acceptable position usiung the PBC condition: (acceptable position means that the molecule distance from the target molecule is smaller then max_distance.)</span>
    <span class="n">L_acceptable_shift</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L_position_possible</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">res_neigh</span> <span class="o">!=</span> <span class="n">residue_nbr</span><span class="p">:</span> <span class="c1">#otherwise it is the target molecule</span>
        <span class="c1"># find if shifting using only the first PBC shell lead to acceptable position for the neighbors:</span>
        <span class="k">for</span> <span class="n">movement</span> <span class="ow">in</span> <span class="n">L_movement</span><span class="p">:</span>
            <span class="n">pos_temp</span> <span class="o">=</span> <span class="n">L_pos_neigh_mean</span> <span class="o">+</span> <span class="n">movement</span>
            <span class="n">distance_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">mean_position</span><span class="o">-</span><span class="n">pos_temp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">distance_temp</span> <span class="o">&lt;</span> <span class="n">max_distance</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_acceptable_shift</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">L_acceptable_shift</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">movement</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">there_is_already</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">already_accepted_shift</span> <span class="ow">in</span> <span class="n">L_acceptable_shift</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">movement</span><span class="o">-</span><span class="n">already_accepted_shift</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
                            <span class="n">there_is_already</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">there_is_already</span><span class="p">:</span>
                        <span class="n">L_acceptable_shift</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">movement</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">L_acceptable_shift</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])])</span> <span class="c1"># add [0, 0, 0] which would be remote after</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_acceptable_shift</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># find if using more PBC condition can lead to acceptable position for the neighbourg molecule</span>
        <span class="n">continue_search</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">continue_search</span><span class="p">:</span>
            <span class="n">L_new_acceptable_shift</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">L_acceptable_shift</span><span class="p">:</span>
                 <span class="k">for</span> <span class="n">movement</span> <span class="ow">in</span> <span class="n">L_movement</span><span class="p">:</span>
                    <span class="n">pos_temp</span> <span class="o">=</span> <span class="n">L_pos_neigh_mean</span> <span class="o">+</span> <span class="n">movement</span> <span class="o">+</span> <span class="n">shift</span>
                    <span class="n">distance_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">mean_position</span><span class="o">-</span><span class="n">pos_temp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">distance_temp</span> <span class="o">&lt;</span> <span class="n">max_distance</span><span class="p">:</span>
                        <span class="n">there_is_already</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">for</span> <span class="n">already_accepted_shift</span> <span class="ow">in</span> <span class="n">L_acceptable_shift</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">movement</span> <span class="o">+</span> <span class="n">shift</span><span class="o">-</span><span class="n">already_accepted_shift</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
                                <span class="n">there_is_already</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">there_is_already</span><span class="p">:</span>
                            <span class="n">L_new_acceptable_shift</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">movement</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_new_acceptable_shift</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">continue_search</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">new_shift</span> <span class="ow">in</span> <span class="n">L_new_acceptable_shift</span><span class="p">:</span>
                    <span class="n">L_acceptable_shift</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_shift</span><span class="p">)</span>
                                
    <span class="k">if</span> <span class="n">res_neigh</span> <span class="o">==</span> <span class="n">residue_nbr</span><span class="p">:</span> <span class="c1"># it is the target molecule</span>
        <span class="n">L_acceptable_shift</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># remove the target position from the &#39;&#39;neighbourg position&#39;&#39;</span>
                
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_acceptable_shift</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># Add all the acceptable position found </span>
        <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">L_acceptable_shift</span><span class="p">:</span>
            <span class="n">L_pos_neigh_centered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_pos_neigh</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">atom_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L_pos_neigh_centered</span><span class="p">)):</span>
                <span class="n">L_pos_neigh_centered</span><span class="p">[</span><span class="n">atom_number</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_pos_neigh_centered</span><span class="p">[</span><span class="n">atom_number</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span> <span class="o">-</span> <span class="n">mean_position</span>
            <span class="n">L_position_possible</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L_pos_neigh_centered</span><span class="p">))</span>
            
    <span class="k">return</span><span class="p">(</span><span class="n">L_position_possible</span><span class="p">)</span></div>


<span class="c1">#################################################################################################################################</span>

               
<div class="viewcode-block" id="construct_pbc_movement">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.construct_pbc_movement">[docs]</a>
<span class="k">def</span> <span class="nf">construct_pbc_movement</span><span class="p">(</span><span class="n">env_authorised_pbc_condition</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Construct the list of the possible movement (to increase the sample size) according to the PBC condition and the authorised direction. Note that this function have to be called for every time step since the box size may vary in time. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">movement_to_try</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">env_authorised_pbc_condition</span><span class="p">:</span>
        <span class="n">movement_to_try</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">L_box_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span> 
    <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">env_authorised_pbc_condition</span><span class="p">:</span>
        <span class="n">movement_to_try</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">]))</span>
    <span class="k">if</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">env_authorised_pbc_condition</span><span class="p">:</span>
        <span class="n">movement_to_try</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">L_box_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]]))</span>
    <span class="n">L_movement</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]</span>
    <span class="n">L_movement</span> <span class="o">=</span> <span class="n">recurcive_pbc_movement_constructor</span><span class="p">(</span><span class="n">movement_to_try</span><span class="p">,</span> <span class="n">L_movement</span><span class="p">)</span> <span class="c1"># the list . The first one is [0, 0, 0]. </span>
    <span class="k">return</span><span class="p">(</span><span class="n">L_movement</span><span class="p">)</span></div>

               
<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="recurcive_pbc_movement_constructor">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.recurcive_pbc_movement_constructor">[docs]</a>
<span class="k">def</span> <span class="nf">recurcive_pbc_movement_constructor</span><span class="p">(</span><span class="n">movement_to_try</span><span class="p">,</span> <span class="n">L_movement</span><span class="p">):</span>
    <span class="n">movement_todo</span> <span class="o">=</span> <span class="n">movement_to_try</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">L_movement_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">movement</span> <span class="ow">in</span> <span class="n">L_movement</span><span class="p">:</span>
        <span class="n">L_movement_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">movement</span><span class="p">)</span>
        <span class="n">L_movement_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">movement</span> <span class="o">+</span> <span class="n">movement_todo</span><span class="p">)</span>
        <span class="n">L_movement_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">movement</span> <span class="o">-</span> <span class="n">movement_todo</span><span class="p">)</span>
 
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">movement_to_try</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">L_movement_new</span> <span class="o">=</span> <span class="n">recurcive_pbc_movement_constructor</span><span class="p">(</span><span class="n">movement_to_try</span><span class="p">,</span> <span class="n">L_movement_new</span><span class="p">)</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">L_movement_new</span><span class="p">)</span></div>


<span class="sd">&#39;&#39;&#39;</span>

<span class="sd">def built_environment_MDAnalysis(residue_nbr, mean_position, target_molecule_type_module, max_distance, GP, u, ts, L_box_size, L_name_partner, just_number_mol):</span>
<span class="sd">    </span>
<span class="sd">    # TODO</span>
<span class="sd">    </span>
<span class="sd">    print(&#39;ok&#39;, max_distance)</span>
<span class="sd">    MDAnalysis.core.flags[&#39;use_periodic_selections&#39;] = True</span>
<span class="sd">    MDAnalysis.core.flags[&#39;use_KDTree_routines&#39;] = False</span>
<span class="sd">    ag_updating = u.select_atoms(&quot;around &quot; + str(max_distance) + &quot; resid &quot; + str(residue_nbr), updating=True)</span>
<span class="sd">    </span>
<span class="sd">    L_neighbourhood = ag_updating.resids</span>
<span class="sd">    print(len(L_neighbourhood))</span>
<span class="sd">    L_neighbourhood_cleaned = []</span>
<span class="sd">    L_neighbourhood_names = []</span>
<span class="sd">    if isinstance(L_name_partner, bool) and not L_name_partner:</span>
<span class="sd">        for res_neigh in L_neighbourhood:</span>
<span class="sd">            if res_neigh not in L_neighbourhood_cleaned:</span>
<span class="sd">                for molecule_type_rep in GP.L_mt_key_mt: # Find the name of the molecule </span>
<span class="sd">                    if res_neigh in molecule_type_rep[1]:</span>
<span class="sd">                        name_neigh_temp = molecule_type_rep[0]</span>
<span class="sd">                L_neighbourhood_cleaned.append(res_neigh)</span>
<span class="sd">                L_neighbourhood_names.append(name_neigh_temp)</span>
<span class="sd">    elif not isinstance(L_name_partner, bool): # Looking only for a specific molecule type</span>
<span class="sd">        # What are the number of the molecule with the target name: </span>
<span class="sd">        for ttt in GP.L_mt_key_mt:</span>
<span class="sd">            if ttt[0] == L_name_partner:</span>
<span class="sd">                L_key_mol_partner = ttt[1]</span>

<span class="sd">        for res_neigh in L_neighbourhood:</span>
<span class="sd">            if res_neigh in L_key_mol_partner:</span>
<span class="sd">                if res_neigh not in L_neighbourhood_cleaned:</span>
<span class="sd">                    L_neighbourhood_cleaned.append(res_neigh)</span>
<span class="sd">                    L_neighbourhood_names.append(L_name_partner) #same name for every molecule since it has been asked.</span>
<span class="sd">    else:</span>
<span class="sd">        raise Exception(&#39;WARNING: Strange case, please check the L_name_partner optional parameter&#39;)</span>

<span class="sd">    Nbr_neigh = len(L_neighbourhood_cleaned)</span>
<span class="sd">    if Nbr_neigh == 0: #No neighbourg found</span>
<span class="sd">        if just_number_mol:</span>
<span class="sd">            return(False)</span>
<span class="sd">        else:</span>
<span class="sd">            return(False, False)</span>

<span class="sd">    if just_number_mol:</span>
<span class="sd">        return(L_neighbourhood_cleaned)</span>

<span class="sd">    L_environment = [] # I cannot use np.array since the size of the molecule can be different (different number of atoms)</span>
<span class="sd">    for k_neigh in range (0, Nbr_neigh, 1):</span>
<span class="sd">        res_neigh = L_neighbourhood_cleaned[k_neigh]</span>
<span class="sd">        L_pos_neigh = u.select_atoms(&quot;resid &quot; + str(res_neigh)).positions</span>
<span class="sd">        module_neigh_temp = importlib.import_module(L_neighbourhood_names[k_neigh])</span>
<span class="sd">        smparameter = module_neigh_temp.info_molecule(SingleMoleculeParameter())</span>
<span class="sd">        #recentering the position of the neighbourg: avoiding PBC problems</span>
<span class="sd">        yhg  </span>
<span class="sd">        # L_pos_neigh_centered = centering_position_neighbourg(L_pos_neigh, mean_position, max_distance, neigh_size_max, L_box_size)</span>
<span class="sd">        L_environment.append(np.array(L_pos_neigh_centered))</span>
<span class="sd">        return(L_environment, L_neighbourhood_cleaned)</span>

<span class="sd">#################################################################################################################################</span>
<span class="sd">#################################################################################################################################</span>
<span class="sd">#################################################################################################################################</span>
<span class="sd">#################################################################################################################################</span>

<span class="sd">def built_environement_PBC(residue_nbr, mean_position, target_molecule_type_module, max_distance, GP, u, ts, L_box_size, L_name_partner, just_number_mol):</span>
<span class="sd">    L_environment = []</span>
<span class="sd">    L_neighbourhood_cleaned = []</span>
<span class="sd">    # Read the list of the PBC move authorised:</span>
<span class="sd">    L_movement = ts.L_movment_environment_building_pbc #The first one is [0, 0, 0]. </span>
<span class="sd">        </span>
<span class="sd">    # Try for every molecule of the box if they can be a acceptable position usiung the PBC condition: (acceptable position means that the molecule distance from the target molecule is smaller then max_distance.)</span>
<span class="sd">    for molecule_type_rep in GP.L_mt_key_mt: # Goes over all the molecule type</span>
<span class="sd">        name_neigh_temp = molecule_type_rep[0]</span>
<span class="sd">        module_neigh_temp = importlib.import_module(name_neigh_temp)</span>
<span class="sd">        smparameter = module_neigh_temp.info_molecule(SingleMoleculeParameter())</span>
<span class="sd">        for res_neigh in molecule_type_rep[1]: # goes over all the molecule of the molecule type</span>
<span class="sd">            L_pos_neigh = u.select_atoms(&quot;resid &quot; + str(res_neigh)).positions</span>
<span class="sd">            L_pos_neigh = geometry_manager.check_molecule_geometry(smparameter, L_pos_neigh, L_box_size) #make sure the molecule is not cutted by PBC condition</span>
<span class="sd">            L_pos_neigh_mean = module_neigh_temp.compute_mean_position(L_pos_neigh)</span>
<span class="sd">            L_acceptable_shift = []</span>
<span class="sd">            if res_neigh != residue_nbr: #otherwise it is the target molecule</span>
<span class="sd">                # find if shifting using only the first PBC shell lead to acceptable position for the neighbors:</span>
<span class="sd">                for movement in L_movement:</span>
<span class="sd">                    pos_temp = L_pos_neigh_mean + movement</span>
<span class="sd">                    distance_temp = np.sqrt(np.sum((mean_position-pos_temp)**2))</span>
<span class="sd">                    if distance_temp &lt; max_distance:</span>
<span class="sd">                        if len(L_acceptable_shift) == 0:</span>
<span class="sd">                            L_acceptable_shift.append(movement)</span>
<span class="sd">                        else:</span>
<span class="sd">                            there_is_already = False</span>
<span class="sd">                            for already_accepted_shift in L_acceptable_shift:</span>
<span class="sd">                                if np.sqrt(np.sum((movement-already_accepted_shift)**2)) &lt; 0.01:</span>
<span class="sd">                                    there_is_already = True</span>
<span class="sd">                            if not there_is_already:</span>
<span class="sd">                                L_acceptable_shift.append(movement)</span>
<span class="sd">            else: </span>
<span class="sd">                L_acceptable_shift.append([np.array([0, 0, 0])]) # add [0, 0, 0] which would be remote after</span>
<span class="sd">                    </span>
<span class="sd">            if len(L_acceptable_shift) != 0: # find if using more PBC condition can lead to acceptable position for the neighbourg molecule</span>
<span class="sd">                continue_search = True</span>
<span class="sd">                while continue_search:</span>
<span class="sd">                    L_new_acceptable_shift = []</span>
<span class="sd">                    for shift in L_acceptable_shift:</span>
<span class="sd">                        for movement in L_movement:</span>
<span class="sd">                            pos_temp = L_pos_neigh_mean + movement + shift</span>
<span class="sd">                            distance_temp = np.sqrt(np.sum((mean_position-pos_temp)**2))</span>
<span class="sd">                            if distance_temp &lt; max_distance:</span>
<span class="sd">                                there_is_already = False</span>
<span class="sd">                                for already_accepted_shift in L_acceptable_shift:</span>
<span class="sd">                                    if np.sqrt(np.sum((movement + shift-already_accepted_shift)**2)) &lt; 0.01:</span>
<span class="sd">                                        there_is_already = True</span>
<span class="sd">                                if not there_is_already:</span>
<span class="sd">                                    L_new_acceptable_shift.append(movement + shift)</span>
<span class="sd">                    if len(L_new_acceptable_shift) == 0:</span>
<span class="sd">                        continue_search = False</span>
<span class="sd">                    else:</span>
<span class="sd">                        for new_shift in L_new_acceptable_shift:</span>
<span class="sd">                            L_acceptable_shift.append(new_shift)</span>
<span class="sd">                                </span>
<span class="sd">            if res_neigh == residue_nbr: # it is the target molecule</span>
<span class="sd">                L_acceptable_shift.pop(0) # remove the target position from the &#39;&#39;neighbourg position&#39;&#39;</span>
<span class="sd">                </span>
<span class="sd">            if len(L_acceptable_shift) != 0: # Add all the acceptable position found </span>
<span class="sd">                for shift in L_acceptable_shift:</span>
<span class="sd">                    L_pos_neigh_centered = np.array(L_pos_neigh)</span>
<span class="sd">                    for atom_number in range(len(L_pos_neigh_centered)):</span>
<span class="sd">                        L_pos_neigh_centered[atom_number] = L_pos_neigh_centered[atom_number] + shift - mean_position</span>
<span class="sd">                    L_environment.append(np.array(L_pos_neigh_centered))</span>
<span class="sd">                    L_neighbourhood_cleaned.append(res_neigh)</span>
<span class="sd">  </span>
<span class="sd">    if len(L_neighbourhood_cleaned) == 0: #No neighbourg found</span>
<span class="sd">        return(False, False)</span>
<span class="sd">    else:           </span>
<span class="sd">        return(L_environment, L_neighbourhood_cleaned)</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>

<div class="viewcode-block" id="centering_position_neighbourg">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.centering_position_neighbourg">[docs]</a>
<span class="k">def</span> <span class="nf">centering_position_neighbourg</span><span class="p">(</span><span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">mean_position</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">smparameter</span><span class="p">,</span> <span class="n">box_size</span><span class="p">):</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_pos_neigh</span><span class="p">)</span>
    <span class="n">mindistance_init</span> <span class="o">=</span> <span class="n">max_distance</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">10</span>
    <span class="k">for</span> <span class="n">atomtype</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">L_pos_neigh</span><span class="p">[</span><span class="n">atomtype</span><span class="p">]</span><span class="o">-</span><span class="n">mean_position</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">mindistance_init</span><span class="p">:</span>
            <span class="n">mindistance_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">L_pos_neigh</span><span class="p">[</span><span class="n">atomtype</span><span class="p">]</span><span class="o">-</span><span class="n">mean_position</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            
    <span class="n">L_pos_neigh_united</span> <span class="o">=</span> <span class="n">geometry_manager</span><span class="o">.</span><span class="n">check_molecule_geometry</span><span class="p">(</span><span class="n">smparameter</span><span class="p">,</span> <span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">box_size</span><span class="p">)</span> <span class="c1">#make sure the molecule is not cutted by PBC condition</span>
    
    <span class="n">pos_tomove_neigh</span> <span class="o">=</span> <span class="n">pbc_condition_neigh</span><span class="p">(</span><span class="n">mean_position</span><span class="p">,</span> <span class="n">L_pos_neigh_united</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_distance</span><span class="o">+</span><span class="n">smparameter</span><span class="o">.</span><span class="n">size_typical_molecule</span><span class="p">,</span> <span class="n">box_size</span><span class="p">)</span>
    <span class="n">shift_to_apply</span> <span class="o">=</span> <span class="n">L_pos_neigh_united</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos_tomove_neigh</span>
    
    <span class="n">L_pos_neigh_shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">atomtype</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">L_pos_neigh_shifted</span><span class="p">[</span><span class="n">atomtype</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_pos_neigh_united</span><span class="p">[</span><span class="n">atomtype</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift_to_apply</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_position</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    
    <span class="n">mindistance</span> <span class="o">=</span> <span class="n">max_distance</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">10</span>
    <span class="k">for</span> <span class="n">atomtype</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">L_pos_neigh_shifted</span><span class="p">[</span><span class="n">atomtype</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">mindistance</span><span class="p">:</span>
            <span class="n">mindistance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">L_pos_neigh_shifted</span><span class="p">[</span><span class="n">atomtype</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            
    <span class="k">if</span> <span class="n">mindistance</span> <span class="o">&gt;</span>  <span class="n">max_distance</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;WARNING: I have not been able to shift properly the neighbourg molecule.&#39;</span><span class="p">,</span> <span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">mean_position</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">mindistance_init</span><span class="p">,</span> <span class="n">mindistance</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">L_pos_neigh_united</span><span class="p">,</span> <span class="n">shift_to_apply</span><span class="p">,</span> <span class="n">L_pos_neigh_shifted</span><span class="p">)</span>
        
    <span class="k">return</span><span class="p">(</span><span class="n">L_pos_neigh_shifted</span><span class="p">)</span></div>


<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################    </span>

<div class="viewcode-block" id="centering_position_neighbourg_old">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.centering_position_neighbourg_old">[docs]</a>
<span class="k">def</span> <span class="nf">centering_position_neighbourg_old</span><span class="p">(</span><span class="n">L_pos_neigh</span><span class="p">,</span> <span class="n">mean_position</span><span class="p">,</span> <span class="n">max_distance</span><span class="p">,</span> <span class="n">neigh_size_max</span><span class="p">,</span> <span class="n">box_size</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">L_pos_neigh</span><span class="p">)</span>
    <span class="n">min_distance</span> <span class="o">=</span> <span class="n">max_distance</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> 
    <span class="n">L_pos_neigh_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">atomtype</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">L_pos_neigh_shift</span><span class="p">[</span><span class="n">atomtype</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_pos_neigh</span><span class="p">[</span><span class="n">atomtype</span><span class="p">][</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_position</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="c1"># shift the neigbourg in the frame where the target molecule is at the center. </span>
    <span class="k">for</span> <span class="n">atomtype</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">L_pos_neigh_shift</span><span class="p">[</span><span class="n">atomtype</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">max_distance</span><span class="p">:</span> <span class="c1"># resolve PBC probeme. May not work for all the atoms because the neighbourg is select if at least one atom is close enough to the target molecule. Not all of them. </span>
            <span class="c1">#print(L_pos_neigh_shift, np.sqrt(np.sum(L_pos_neigh_shift[atomtype]**2)))</span>
            <span class="n">L_pos_neigh_shift</span><span class="p">[</span><span class="n">atomtype</span><span class="p">]</span> <span class="o">=</span> <span class="n">pbc_condition_neigh</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">L_pos_neigh_shift</span><span class="p">[</span><span class="n">atomtype</span><span class="p">],</span> <span class="n">max_distance</span><span class="o">+</span><span class="n">neigh_size_max</span><span class="p">,</span> <span class="n">box_size</span><span class="p">)</span>             <span class="c1"># There are some PBC problems for this atom. Trying to resolve it</span>
            <span class="c1">#print(L_pos_neigh_shift, np.sqrt(np.sum(L_pos_neigh_shift[atomtype]**2)))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">L_pos_neigh_shift</span><span class="p">[</span><span class="n">atomtype</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">:</span> <span class="c1"># try to find which atom is the closest to the target position. Then we will use this one to check the PBC of the molecule. </span>
            <span class="n">min_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">L_pos_neigh_shift</span><span class="p">[</span><span class="n">atomtype</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">atomtype_min_distance</span> <span class="o">=</span> <span class="n">atomtype</span>
    
    <span class="c1"># RQ: if no atomtype_min_distance is found, this is very weird since this neighbourg should be not that far from the mean position...</span>
    <span class="k">for</span> <span class="n">atomtype</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># check the PBC of the neighbourg. The new &#39;&#39;reference position&#39;&#39; is the atomic position of the closest atom (from the target molecule position).</span>
        <span class="c1">#if np.sqrt(np.sum((L_pos_neigh_shift[atomtype]-L_pos_neigh_shift[atomtype_min_distance])**2)) &gt; neigh_size_max:</span>
        <span class="c1">#    L_pos_neigh_shift[atomtype] = pbc_condition_neigh(L_pos_neigh_shift[atomtype_min_distance], L_pos_neigh_shift[atomtype], neigh_size_max, box_size) </span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">L_pos_neigh_shift</span><span class="p">[</span><span class="n">atomtype</span><span class="p">]</span><span class="o">-</span><span class="n">L_pos_neigh_shift</span><span class="p">[</span><span class="n">atomtype_min_distance</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">neigh_size_max</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;WARNING: Probleme encountered during the PBC condition of the environment building. Please check it&#39;</span><span class="p">)</span>
            
    <span class="k">return</span><span class="p">(</span><span class="n">L_pos_neigh_shift</span><span class="p">)</span>  </div>


<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">################################################################################################################################# </span>

<div class="viewcode-block" id="pbc_condition_neigh">
<a class="viewcode-back" href="../../Frog.html#Frog.universe_manager.pbc_condition_neigh">[docs]</a>
<span class="k">def</span> <span class="nf">pbc_condition_neigh</span><span class="p">(</span><span class="n">pos_ref</span><span class="p">,</span> <span class="n">pos_tomove</span><span class="p">,</span> <span class="n">max_norm</span><span class="p">,</span> <span class="n">L_pbc_parameter</span><span class="p">):</span>
    <span class="n">pos_tomove_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_tomove</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">pos_tomove_temp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos_ref</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">max_norm</span><span class="p">:</span>
            <span class="n">pos_tomove_temp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_tomove_temp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">L_pbc_parameter</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">pos_tomove_temp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos_ref</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">delta</span> <span class="o">&gt;</span> <span class="n">max_norm</span><span class="p">:</span>
            <span class="n">pos_tomove_temp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos_tomove_temp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">L_pbc_parameter</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">pos_tomove_temp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">pos_ref</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            
    <span class="k">return</span><span class="p">(</span><span class="n">pos_tomove_temp</span><span class="p">)</span></div>


<span class="c1">#################################################################################################################################</span>
<span class="c1">#################################################################################################################################</span>
<span class="c1">################################################################################################################################# </span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/frog_logo.png" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Installation/how_to_install_frog.html">1. How to Install Frog?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tutorials/tutorial_index.html">2. Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../GlobalParameter/gp_index.html">3. Global Parameter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MoleculeType/mt_index.html">4. Molecule Type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Diagram/diagram_index.html">5. Diagram</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../OpticalAnalysis/optical_analysis_index.html">6. Optical Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Frog.html">7. Frog package</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Guillaume Le Breton.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>